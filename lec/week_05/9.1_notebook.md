Here is the converted content for **9.1_notebook.ipynb**:

```markdown
```python
%pylab inline

import numpy as np
import matplotlib.pyplot as plt
from ipywidgets import interact, interactive, fixed, interact_manual,widgets
import ipywidgets as widgets

print('version of ipwidgets=',widgets.__version__)

from lib.Reconstruction_plots import *
from lib.decomposer import Eigen_decomp
from lib.YearPlotter import YearPlotter

import warnings
warnings.filterwarnings('ignore')
_figsize=[8,6]

```

```python
"""
RETURNS ->

%pylab is deprecated, use %matplotlib inline and import the required libraries.
Populating the interactive namespace from numpy and matplotlib
version of ipwidgets= 8.1.8

/home/scotty/dev/dsc232/lec/week_05/.venv/lib/python3.11/site-packages/IPython/core/magics/pylab.py:166: UserWarning: pylab import has clobbered these variables: ['interactive']
`%matplotlib` prevents importing * from pylab and numpy
  warn("pylab import has clobbered these variables: %s"  % clobbered +
"""

```

## Functions as vectors

### temperature per day as a function

The records of temperatures for each day can be represented as a function from  to the temperature on that day (0=TMin, 1=TMAX, 2=TOBS).

We want to find a way to approximate these functions using a set of basis function.

<img src="Figures/TemperaturesExamples.png" width="600">

* How can we visualize vectors that are in dimension higher than 3?
* One good way to visualize a -dimensional vector is to draw it as a function from  to the reals.

```python
d=4
plt.stem([1,-3,2,0])
grid()

```

```python
"""
RETURNS ->

<Figure size 640x480 with 1 Axes>
"""

```

* All of the vector operations are well defined, including approximating a function using an orthonormal set of functions.

To get an intuition about the working of the PCA, we used an example in the plane, or .
While useful for intuition, this is not the typical case in which we use PCA. Typically we are interested in vectors in a space whose dimension is in the hundreds or more.

How can we depict such vectors? If the coordinates of the vector have a natural order. For example, if the coordinates correspond to a grid of times, then a good representation is to make a plot in which the -axis is the time and the -axis is the value that corresponds to this time.

Later in this class we will consider vectors that correspond to the temperature at a particular location each day of the year. These vectors will be of length 365 (we omit the extra days of leap years) and the PCA analysis will reveal the low dimensional subspace.

### Function approximation

For simplicity Consider the vectors that are defined by sinusoidal functions.

```python
# We define a grid that extends from o to 2*pi
step=2*pi/365
x=arange(0,2*pi,step)
len(x)

```

```python
"""
RETURNS ->

365
"""

```

#### Define an orthonormal set

The dimension of the space is 365 (arbitrary choice: the number of days in a year).

We define some functions based on  and 

```python
c=sqrt(step/(pi))
v=[]
v.append(np.array(cos(0*x))*c/sqrt(2))
v.append(np.array(sin(x))*c)
v.append(np.array(cos(x))*c)
v.append(np.array(sin(2*x))*c)
v.append(np.array(cos(2*x))*c)
v.append(np.array(sin(3*x))*c)
v.append(np.array(cos(3*x))*c)
v.append(np.array(sin(4*x))*c)
v.append(np.array(cos(4*x))*c)

print("v contains %d vectors"%(len(v)))

```

```python
"""
RETURNS ->

v contains 9 vectors
"""

```

```python
U=vstack(v).transpose()
shape(U)

```

```python
"""
RETURNS ->

(365, 9)
"""

```

### Approximating an arbitrary function

We now take an unrelated function 
and see how we can use the basis matrix `U` to approximate it.

```python
f=abs(x-4)

```

```python
eigen_decomp=Eigen_decomp(x,f,np.zeros(len(x)),U)
plotter=recon_plot(eigen_decomp,year_axis=False,interactive=True,figsize=_figsize);
display(plotter.get_Interactive())

```

```python
"""
RETURNS ->

VBox(children=(HBox(children=(FloatSlider(value=0.0, description='c0', max=32.29570559348949, orientation='ver…
"""

```

#### Food for thought

Visually, it is clear that  is getting close to  as  increases. To quantify the improvement, compute
$ | g(i)- f |_2 $ as a function of 

### Recovering from Noise

```python
noise=np.random.normal(size=x.shape)
f1=2*v[1]-4*v[5]
f2=f1+0.3*noise

```

```python
eigen_decomp=Eigen_decomp(x,f2,np.zeros(len(x)),U)
plotter=recon_plot(eigen_decomp,year_axis=False,interactive=True,figsize=_figsize);
display(plotter.get_Interactive())

```

```python
"""
RETURNS ->

VBox(children=(HBox(children=(FloatSlider(value=0.0, description='c0', max=2.031575791925349, orientation='ver…
"""

```

```

```
